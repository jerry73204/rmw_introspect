#+TITLE: RMW Introspect API Design
#+AUTHOR: ROS-Plan Contributors
#+DATE: 2025-10-22
#+OPTIONS: toc:2 num:t

* Overview

This document specifies the API design for the intermediate layer mode of
rmw_introspect, including environment variables, function signatures,
wrapper structures, and forwarding patterns.

* Environment Variables API

** Configuration Variables

*** RMW_IMPLEMENTATION
- *Type*: String
- *Required*: Yes (for ROS 2)
- *Value*: ~rmw_introspect_cpp~
- *Purpose*: Tells ROS 2 to load rmw_introspect as the RMW implementation
- *Example*: ~export RMW_IMPLEMENTATION=rmw_introspect_cpp~

*** RMW_INTROSPECT_DELEGATE_TO
- *Type*: String
- *Required*: Yes (for intermediate layer mode)
- *Default*: None (if unset, recording-only mode)
- *Valid Values*: Any valid RMW implementation name
  - ~rmw_fastrtps_cpp~ (Fast DDS)
  - ~rmw_cyclonedds_cpp~ (CycloneDDS)
  - ~rmw_connextdds~ (RTI Connext)
  - ~rmw_gurumdds_cpp~ (GurumDDS)
- *Purpose*: Specifies which real RMW implementation to forward calls to
- *Validation*: Must start with ~rmw_~ and contain only alphanumeric and underscore
- *Example*: ~export RMW_INTROSPECT_DELEGATE_TO=rmw_fastrtps_cpp~

*** RMW_INTROSPECT_OUTPUT
- *Type*: File path
- *Required*: No
- *Default*: ~/tmp/rmw_introspect_<pid>.json~
- *Purpose*: Where to write introspection data
- *Example*: ~export RMW_INTROSPECT_OUTPUT=/tmp/my_node_interfaces.json~

*** RMW_INTROSPECT_FORMAT
- *Type*: String
- *Required*: No
- *Default*: ~json~
- *Valid Values*: ~json~, ~yaml~
- *Purpose*: Output file format
- *Example*: ~export RMW_INTROSPECT_FORMAT=yaml~

*** RMW_INTROSPECT_AUTO_EXPORT
- *Type*: Boolean (as string)
- *Required*: No
- *Default*: ~1~ (enabled)
- *Valid Values*: ~0~ (disabled), ~1~ (enabled)
- *Purpose*: Whether to automatically export introspection data on shutdown
- *Example*: ~export RMW_INTROSPECT_AUTO_EXPORT=0~

*** RMW_INTROSPECT_VERBOSE
- *Type*: Boolean (as string)
- *Required*: No
- *Default*: ~0~ (disabled)
- *Valid Values*: ~0~ (disabled), ~1~ (enabled)
- *Purpose*: Enable verbose logging for debugging
- *Example*: ~export RMW_INTROSPECT_VERBOSE=1~

** Mode Selection Logic

#+BEGIN_SRC cpp
enum class OperationMode {
  RECORDING_ONLY,     // No RMW_INTROSPECT_DELEGATE_TO set
  INTERMEDIATE_LAYER  // RMW_INTROSPECT_DELEGATE_TO is set
};

OperationMode determine_mode() {
  const char* delegate_to = std::getenv("RMW_INTROSPECT_DELEGATE_TO");
  if (delegate_to && *delegate_to) {
    return OperationMode::INTERMEDIATE_LAYER;
  }
  return OperationMode::RECORDING_ONLY;
}
#+END_SRC

** Usage Examples

*** Recording-Only Mode (Current Behavior)
#+BEGIN_SRC bash
export RMW_IMPLEMENTATION=rmw_introspect_cpp
export RMW_INTROSPECT_OUTPUT=/tmp/talker.json
ros2 run demo_nodes_cpp talker

# Result: No actual communication, only metadata recorded
#+END_SRC

*** Intermediate Layer Mode (New Behavior)
#+BEGIN_SRC bash
export RMW_IMPLEMENTATION=rmw_introspect_cpp
export RMW_INTROSPECT_DELEGATE_TO=rmw_fastrtps_cpp
export RMW_INTROSPECT_OUTPUT=/tmp/talker.json
ros2 run demo_nodes_cpp talker

# Result: Node communicates via FastRTPS + metadata recorded
#+END_SRC

* Wrapper Structure Definitions

** Base Wrapper Pattern

All wrappers follow this pattern:
1. Contain pointer to real RMW handle
2. Store metadata for introspection
3. Optionally cache frequently-accessed data

** ContextWrapper

#+BEGIN_SRC cpp
/// Wrapper for rmw_context_t
struct ContextWrapper {
  // Real RMW context
  rmw_context_t* real_context;

  // Function pointers for real RMW
  RealRMW* real_rmw;

  // Metadata
  std::string real_rmw_name;
  size_t domain_id;

  // Constructor/destructor
  ContextWrapper();
  ~ContextWrapper();

  // Disable copy/move
  ContextWrapper(const ContextWrapper&) = delete;
  ContextWrapper& operator=(const ContextWrapper&) = delete;
};
#+END_SRC

** NodeWrapper

#+BEGIN_SRC cpp
/// Wrapper for rmw_node_t
struct NodeWrapper {
  // Real RMW node handle
  rmw_node_t* real_node;

  // Metadata (for introspection and caching)
  std::string name;
  std::string namespace_;

  // Constructor
  NodeWrapper(rmw_node_t* real, const char* n, const char* ns)
    : real_node(real), name(n), namespace_(ns) {}

  ~NodeWrapper() = default;
};
#+END_SRC

** PublisherWrapper

#+BEGIN_SRC cpp
/// Wrapper for rmw_publisher_t
struct PublisherWrapper {
  // Real RMW publisher handle
  rmw_publisher_t* real_publisher;

  // Metadata
  std::string topic_name;
  std::string message_type;
  rmw_qos_profile_t qos;

  // Constructor
  PublisherWrapper(rmw_publisher_t* real,
                   const std::string& topic,
                   const std::string& type,
                   const rmw_qos_profile_t& q)
    : real_publisher(real),
      topic_name(topic),
      message_type(type),
      qos(q) {}

  ~PublisherWrapper() = default;
};
#+END_SRC

** SubscriptionWrapper

#+BEGIN_SRC cpp
/// Wrapper for rmw_subscription_t
struct SubscriptionWrapper {
  // Real RMW subscription handle
  rmw_subscription_t* real_subscription;

  // Metadata
  std::string topic_name;
  std::string message_type;
  rmw_qos_profile_t qos;

  // Constructor
  SubscriptionWrapper(rmw_subscription_t* real,
                      const std::string& topic,
                      const std::string& type,
                      const rmw_qos_profile_t& q)
    : real_subscription(real),
      topic_name(topic),
      message_type(type),
      qos(q) {}

  ~SubscriptionWrapper() = default;
};
#+END_SRC

** ServiceWrapper

#+BEGIN_SRC cpp
/// Wrapper for rmw_service_t
struct ServiceWrapper {
  // Real RMW service handle
  rmw_service_t* real_service;

  // Metadata
  std::string service_name;
  std::string service_type;
  rmw_qos_profile_t qos;

  // Constructor
  ServiceWrapper(rmw_service_t* real,
                 const std::string& name,
                 const std::string& type,
                 const rmw_qos_profile_t& q)
    : real_service(real),
      service_name(name),
      service_type(type),
      qos(q) {}

  ~ServiceWrapper() = default;
};
#+END_SRC

** ClientWrapper

#+BEGIN_SRC cpp
/// Wrapper for rmw_client_t
struct ClientWrapper {
  // Real RMW client handle
  rmw_client_t* real_client;

  // Metadata
  std::string service_name;
  std::string service_type;
  rmw_qos_profile_t qos;

  // Constructor
  ClientWrapper(rmw_client_t* real,
                const std::string& name,
                const std::string& type,
                const rmw_qos_profile_t& q)
    : real_client(real),
      service_name(name),
      service_type(type),
      qos(q) {}

  ~ClientWrapper() = default;
};
#+END_SRC

** GuardConditionWrapper

#+BEGIN_SRC cpp
/// Wrapper for rmw_guard_condition_t
struct GuardConditionWrapper {
  // Real RMW guard condition handle
  rmw_guard_condition_t* real_guard_condition;

  // Constructor
  explicit GuardConditionWrapper(rmw_guard_condition_t* real)
    : real_guard_condition(real) {}

  ~GuardConditionWrapper() = default;
};
#+END_SRC

** WaitSetWrapper

#+BEGIN_SRC cpp
/// Wrapper for rmw_wait_set_t
struct WaitSetWrapper {
  // Real RMW wait set handle
  rmw_wait_set_t* real_wait_set;

  // Constructor
  explicit WaitSetWrapper(rmw_wait_set_t* real)
    : real_wait_set(real) {}

  ~WaitSetWrapper() = default;
};
#+END_SRC

* RealRMW Structure

** Function Pointer Container

#+BEGIN_SRC cpp
/// Container for real RMW function pointers
struct RealRMW {
  // Library handle
  void* lib_handle;
  std::string implementation_name;

  // --- Core Functions ---

  const char* (*get_implementation_identifier)(void);
  const char* (*get_serialization_format)(void);

  // --- Initialization ---

  rmw_ret_t (*init_options_init)(
    rmw_init_options_t* init_options,
    rcutils_allocator_t allocator);

  rmw_ret_t (*init_options_copy)(
    const rmw_init_options_t* src,
    rmw_init_options_t* dst);

  rmw_ret_t (*init_options_fini)(
    rmw_init_options_t* init_options);

  rmw_ret_t (*init)(
    const rmw_init_options_t* options,
    rmw_context_t* context);

  rmw_ret_t (*shutdown)(
    rmw_context_t* context);

  rmw_ret_t (*context_fini)(
    rmw_context_t* context);

  // --- Node Management ---

  rmw_node_t* (*create_node)(
    rmw_context_t* context,
    const char* name,
    const char* namespace_,
    const rmw_node_options_t* options);

  rmw_ret_t (*destroy_node)(
    rmw_node_t* node);

  const rmw_guard_condition_t* (*node_get_graph_guard_condition)(
    const rmw_node_t* node);

  // --- Publisher ---

  rmw_publisher_t* (*create_publisher)(
    const rmw_node_t* node,
    const rosidl_message_type_support_t* type_support,
    const char* topic_name,
    const rmw_qos_profile_t* qos_profile,
    const rmw_publisher_options_t* publisher_options);

  rmw_ret_t (*destroy_publisher)(
    rmw_node_t* node,
    rmw_publisher_t* publisher);

  rmw_ret_t (*publish)(
    const rmw_publisher_t* publisher,
    const void* ros_message,
    rmw_publisher_allocation_t* allocation);

  rmw_ret_t (*publish_serialized_message)(
    const rmw_publisher_t* publisher,
    const rmw_serialized_message_t* serialized_message,
    rmw_publisher_allocation_t* allocation);

  rmw_ret_t (*borrow_loaned_message)(
    const rmw_publisher_t* publisher,
    const rosidl_message_type_support_t* type_support,
    void** ros_message);

  rmw_ret_t (*return_loaned_message_from_publisher)(
    const rmw_publisher_t* publisher,
    void* loaned_message);

  rmw_ret_t (*publisher_get_actual_qos)(
    const rmw_publisher_t* publisher,
    rmw_qos_profile_t* qos);

  rmw_ret_t (*publisher_count_matched_subscriptions)(
    const rmw_publisher_t* publisher,
    size_t* subscription_count);

  rmw_ret_t (*publisher_assert_liveliness)(
    const rmw_publisher_t* publisher);

  rmw_ret_t (*publisher_wait_for_all_acked)(
    const rmw_publisher_t* publisher,
    rmw_time_t wait_timeout);

  // --- Subscription ---

  rmw_subscription_t* (*create_subscription)(
    const rmw_node_t* node,
    const rosidl_message_type_support_t* type_support,
    const char* topic_name,
    const rmw_qos_profile_t* qos_profile,
    const rmw_subscription_options_t* subscription_options);

  rmw_ret_t (*destroy_subscription)(
    rmw_node_t* node,
    rmw_subscription_t* subscription);

  rmw_ret_t (*take)(
    const rmw_subscription_t* subscription,
    void* ros_message,
    bool* taken,
    rmw_subscription_allocation_t* allocation);

  rmw_ret_t (*take_with_info)(
    const rmw_subscription_t* subscription,
    void* ros_message,
    bool* taken,
    rmw_message_info_t* message_info,
    rmw_subscription_allocation_t* allocation);

  rmw_ret_t (*take_serialized_message)(
    const rmw_subscription_t* subscription,
    rmw_serialized_message_t* serialized_message,
    bool* taken,
    rmw_subscription_allocation_t* allocation);

  rmw_ret_t (*take_serialized_message_with_info)(
    const rmw_subscription_t* subscription,
    rmw_serialized_message_t* serialized_message,
    bool* taken,
    rmw_message_info_t* message_info,
    rmw_subscription_allocation_t* allocation);

  rmw_ret_t (*subscription_get_actual_qos)(
    const rmw_subscription_t* subscription,
    rmw_qos_profile_t* qos);

  rmw_ret_t (*subscription_count_matched_publishers)(
    const rmw_subscription_t* subscription,
    size_t* publisher_count);

  // --- Service ---

  rmw_service_t* (*create_service)(
    const rmw_node_t* node,
    const rosidl_service_type_support_t* type_support,
    const char* service_name,
    const rmw_qos_profile_t* qos_profile);

  rmw_ret_t (*destroy_service)(
    rmw_node_t* node,
    rmw_service_t* service);

  rmw_ret_t (*take_request)(
    const rmw_service_t* service,
    rmw_service_info_t* request_header,
    void* ros_request,
    bool* taken);

  rmw_ret_t (*send_response)(
    const rmw_service_t* service,
    rmw_request_id_t* request_header,
    void* ros_response);

  // --- Client ---

  rmw_client_t* (*create_client)(
    const rmw_node_t* node,
    const rosidl_service_type_support_t* type_support,
    const char* service_name,
    const rmw_qos_profile_t* qos_profile);

  rmw_ret_t (*destroy_client)(
    rmw_node_t* node,
    rmw_client_t* client);

  rmw_ret_t (*send_request)(
    const rmw_client_t* client,
    const void* ros_request,
    int64_t* sequence_id);

  rmw_ret_t (*take_response)(
    const rmw_client_t* client,
    rmw_service_info_t* request_header,
    void* ros_response,
    bool* taken);

  // --- Guard Condition ---

  rmw_guard_condition_t* (*create_guard_condition)(
    rmw_context_t* context);

  rmw_ret_t (*destroy_guard_condition)(
    rmw_guard_condition_t* guard_condition);

  rmw_ret_t (*trigger_guard_condition)(
    const rmw_guard_condition_t* guard_condition);

  // --- Wait Set ---

  rmw_wait_set_t* (*create_wait_set)(
    rmw_context_t* context,
    size_t max_conditions);

  rmw_ret_t (*destroy_wait_set)(
    rmw_wait_set_t* wait_set);

  rmw_ret_t (*wait)(
    rmw_subscriptions_t* subscriptions,
    rmw_guard_conditions_t* guard_conditions,
    rmw_services_t* services,
    rmw_clients_t* clients,
    rmw_events_t* events,
    rmw_wait_set_t* wait_set,
    const rmw_time_t* wait_timeout);

  // --- Graph Queries ---

  rmw_ret_t (*get_node_names)(
    const rmw_node_t* node,
    rcutils_string_array_t* node_names,
    rcutils_string_array_t* node_namespaces);

  rmw_ret_t (*get_node_names_with_enclaves)(
    const rmw_node_t* node,
    rcutils_string_array_t* node_names,
    rcutils_string_array_t* node_namespaces,
    rcutils_string_array_t* enclaves);

  rmw_ret_t (*count_publishers)(
    const rmw_node_t* node,
    const char* topic_name,
    size_t* count);

  rmw_ret_t (*count_subscribers)(
    const rmw_node_t* node,
    const char* topic_name,
    size_t* count);

  rmw_ret_t (*get_gid_for_publisher)(
    const rmw_publisher_t* publisher,
    rmw_gid_t* gid);

  rmw_ret_t (*compare_gids_equal)(
    const rmw_gid_t* gid1,
    const rmw_gid_t* gid2,
    bool* result);

  // --- Serialization ---

  rmw_ret_t (*serialize)(
    const void* ros_message,
    const rosidl_message_type_support_t* type_support,
    rmw_serialized_message_t* serialized_message);

  rmw_ret_t (*deserialize)(
    const rmw_serialized_message_t* serialized_message,
    const rosidl_message_type_support_t* type_support,
    void* ros_message);

  rmw_ret_t (*get_serialized_message_size)(
    const void* ros_message,
    const rosidl_message_type_support_t* type_support,
    size_t* size);

  // Add more functions as needed...

  // Constructor/destructor
  RealRMW();
  ~RealRMW();

  // Load from shared library
  bool load(const char* implementation_name);

  // Unload library
  void unload();

private:
  // Helper to load symbol
  template<typename FuncPtr>
  bool load_symbol(FuncPtr& func_ptr, const char* symbol_name);
};
#+END_SRC

* Function Forwarding Patterns

** Pattern 1: Simple Forwarding (No Handle)

For functions that don't take RMW handles:

#+BEGIN_SRC cpp
extern "C" const char* rmw_get_implementation_identifier(void) {
  // Return OUR identifier, not the real RMW's
  return rmw_introspect_cpp_identifier;
}

extern "C" const char* rmw_get_serialization_format(void) {
  // Forward to real RMW
  if (g_real_rmw && g_real_rmw->get_serialization_format) {
    return g_real_rmw->get_serialization_format();
  }
  // Fallback for recording-only mode
  return "introspect";
}
#+END_SRC

** Pattern 2: Creation Forwarding

For functions that create handles:

#+BEGIN_SRC cpp
rmw_publisher_t* rmw_create_publisher(
  const rmw_node_t* node,
  const rosidl_message_type_support_t* type_support,
  const char* topic_name,
  const rmw_qos_profile_t* qos_profile,
  const rmw_publisher_options_t* publisher_options)
{
  // 1. Validate parameters
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(node, nullptr);
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(type_support, nullptr);
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(topic_name, nullptr);
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(qos_profile, nullptr);

  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(
    node,
    node->implementation_identifier,
    rmw_introspect_cpp_identifier,
    return nullptr);

  // 2. Extract metadata for introspection
  std::string message_type = rmw_introspect::extract_message_type(type_support);

  // 3. Record metadata
  rmw_introspect::PublisherInfo info;
  info.node_name = node->name;
  info.node_namespace = node->namespace_;
  info.topic_name = topic_name;
  info.message_type = message_type;
  info.qos = rmw_introspect::QoSProfile::from_rmw(*qos_profile);
  info.timestamp = get_current_timestamp();

  rmw_introspect::IntrospectionData::instance().record_publisher(info);

  // 4. Check mode
  if (!g_real_rmw) {
    // Recording-only mode: return stub handle
    return create_stub_publisher(node, topic_name, publisher_options);
  }

  // 5. Unwrap node to get real handle
  NodeWrapper* node_wrapper = static_cast<NodeWrapper*>(node->data);
  rmw_node_t* real_node = node_wrapper->real_node;

  // 6. Forward to real RMW
  rmw_publisher_t* real_pub = g_real_rmw->create_publisher(
    real_node,
    type_support,
    topic_name,
    qos_profile,
    publisher_options);

  if (!real_pub) {
    // Real RMW already set error message
    return nullptr;
  }

  // 7. Create wrapper
  auto* wrapper = new (std::nothrow) PublisherWrapper(
    real_pub, topic_name, message_type, *qos_profile);

  if (!wrapper) {
    g_real_rmw->destroy_publisher(real_node, real_pub);
    RMW_SET_ERROR_MSG("failed to allocate publisher wrapper");
    return nullptr;
  }

  // 8. Create public handle
  rmw_publisher_t* pub = new (std::nothrow) rmw_publisher_t;
  if (!pub) {
    g_real_rmw->destroy_publisher(real_node, real_pub);
    delete wrapper;
    RMW_SET_ERROR_MSG("failed to allocate publisher handle");
    return nullptr;
  }

  // 9. Initialize public handle
  pub->implementation_identifier = rmw_introspect_cpp_identifier;
  pub->data = wrapper;
  pub->topic_name = real_pub->topic_name;
  pub->options = real_pub->options;
  pub->can_loan_messages = real_pub->can_loan_messages;

  return pub;
}
#+END_SRC

** Pattern 3: Destruction Forwarding

For functions that destroy handles:

#+BEGIN_SRC cpp
rmw_ret_t rmw_destroy_publisher(
  rmw_node_t* node,
  rmw_publisher_t* publisher)
{
  // 1. Validate parameters
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);

  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(
    publisher,
    publisher->implementation_identifier,
    rmw_introspect_cpp_identifier,
    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);

  // 2. Check mode
  if (!g_real_rmw) {
    // Recording-only mode: just free handle
    delete publisher;
    return RMW_RET_OK;
  }

  // 3. Unwrap handles
  NodeWrapper* node_wrapper = static_cast<NodeWrapper*>(node->data);
  PublisherWrapper* pub_wrapper = static_cast<PublisherWrapper*>(publisher->data);

  rmw_node_t* real_node = node_wrapper->real_node;
  rmw_publisher_t* real_pub = pub_wrapper->real_publisher;

  // 4. Forward to real RMW
  rmw_ret_t ret = g_real_rmw->destroy_publisher(real_node, real_pub);

  // 5. Clean up wrapper and handle (even if real RMW fails)
  delete pub_wrapper;
  delete publisher;

  return ret;
}
#+END_SRC

** Pattern 4: Operation Forwarding

For functions that perform operations on handles:

#+BEGIN_SRC cpp
rmw_ret_t rmw_publish(
  const rmw_publisher_t* publisher,
  const void* ros_message,
  rmw_publisher_allocation_t* allocation)
{
  // 1. Validate parameters
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(ros_message, RMW_RET_INVALID_ARGUMENT);

  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(
    publisher,
    publisher->implementation_identifier,
    rmw_introspect_cpp_identifier,
    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);

  // 2. Check mode
  if (!g_real_rmw) {
    // Recording-only mode: no-op
    return RMW_RET_OK;
  }

  // 3. Unwrap handle
  PublisherWrapper* wrapper = static_cast<PublisherWrapper*>(publisher->data);
  rmw_publisher_t* real_pub = wrapper->real_publisher;

  // 4. Forward to real RMW
  return g_real_rmw->publish(real_pub, ros_message, allocation);
}
#+END_SRC

** Pattern 5: Query Forwarding

For functions that query information:

#+BEGIN_SRC cpp
rmw_ret_t rmw_publisher_get_actual_qos(
  const rmw_publisher_t* publisher,
  rmw_qos_profile_t* qos)
{
  // 1. Validate parameters
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(qos, RMW_RET_INVALID_ARGUMENT);

  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(
    publisher,
    publisher->implementation_identifier,
    rmw_introspect_cpp_identifier,
    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);

  // 2. Check mode
  if (!g_real_rmw) {
    // Recording-only mode: return cached QoS from wrapper
    PublisherWrapper* wrapper = static_cast<PublisherWrapper*>(publisher->data);
    *qos = wrapper->qos;
    return RMW_RET_OK;
  }

  // 3. Unwrap and forward to real RMW
  PublisherWrapper* wrapper = static_cast<PublisherWrapper*>(publisher->data);
  return g_real_rmw->publisher_get_actual_qos(wrapper->real_publisher, qos);
}
#+END_SRC

** Pattern 6: Graph Query Forwarding

For graph queries that don't modify handles:

#+BEGIN_SRC cpp
rmw_ret_t rmw_count_publishers(
  const rmw_node_t* node,
  const char* topic_name,
  size_t* count)
{
  // 1. Validate parameters
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(topic_name, RMW_RET_INVALID_ARGUMENT);
  RCUTILS_CHECK_ARGUMENT_FOR_NULL(count, RMW_RET_INVALID_ARGUMENT);

  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(
    node,
    node->implementation_identifier,
    rmw_introspect_cpp_identifier,
    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);

  // 2. Check mode
  if (!g_real_rmw) {
    // Recording-only mode: no graph info
    *count = 0;
    return RMW_RET_OK;
  }

  // 3. Unwrap and forward
  NodeWrapper* wrapper = static_cast<NodeWrapper*>(node->data);
  return g_real_rmw->count_publishers(wrapper->real_node, topic_name, count);
}
#+END_SRC

* Helper Function APIs

** Unwrapping Helpers

#+BEGIN_SRC cpp
namespace rmw_introspect {
namespace internal {

/// Unwrap a node handle
inline rmw_node_t* unwrap_node(const rmw_node_t* node) {
  assert(node);
  assert(node->implementation_identifier == rmw_introspect_cpp_identifier);
  auto* wrapper = static_cast<NodeWrapper*>(node->data);
  return wrapper->real_node;
}

/// Unwrap a publisher handle
inline rmw_publisher_t* unwrap_publisher(const rmw_publisher_t* pub) {
  assert(pub);
  assert(pub->implementation_identifier == rmw_introspect_cpp_identifier);
  auto* wrapper = static_cast<PublisherWrapper*>(pub->data);
  return wrapper->real_publisher;
}

/// Unwrap a subscription handle
inline rmw_subscription_t* unwrap_subscription(const rmw_subscription_t* sub) {
  assert(sub);
  assert(sub->implementation_identifier == rmw_introspect_cpp_identifier);
  auto* wrapper = static_cast<SubscriptionWrapper*>(sub->data);
  return wrapper->real_subscription;
}

// ... similar for service, client, guard_condition, wait_set

}  // namespace internal
}  // namespace rmw_introspect
#+END_SRC

** Mode Checking Helper

#+BEGIN_SRC cpp
namespace rmw_introspect {
namespace internal {

/// Check if we're running in intermediate layer mode
inline bool is_intermediate_mode() {
  return g_real_rmw != nullptr;
}

/// Check if we're running in recording-only mode
inline bool is_recording_only_mode() {
  return g_real_rmw == nullptr;
}

}  // namespace internal
}  // namespace rmw_introspect
#+END_SRC

** Timestamp Helper

#+BEGIN_SRC cpp
namespace rmw_introspect {

/// Get current timestamp in seconds since epoch
inline double get_current_timestamp() {
  auto now = std::chrono::system_clock::now();
  auto duration = now.time_since_epoch();
  return std::chrono::duration<double>(duration).count();
}

}  // namespace rmw_introspect
#+END_SRC

* Error Handling API

** Error Classification

#+BEGIN_SRC cpp
namespace rmw_introspect {
namespace internal {

enum class ErrorSource {
  INTROSPECTION_LAYER,  // Error in our code
  REAL_RMW,             // Error from delegated RMW
  PARAMETER_VALIDATION  // Invalid parameters from caller
};

}  // namespace internal
}  // namespace rmw_introspect
#+END_SRC

** Error Reporting Pattern

#+BEGIN_SRC cpp
// When we detect an error
RMW_SET_ERROR_MSG("rmw_introspect: failed to allocate wrapper");
return RMW_RET_ERROR;

// When real RMW fails
// DO NOT overwrite error message, just propagate return code
rmw_ret_t ret = g_real_rmw->some_function(...);
if (ret != RMW_RET_OK) {
  // Real RMW already set error message via RMW_SET_ERROR_MSG
  return ret;
}

// When adding context to real RMW error
char error_msg[512];
snprintf(error_msg, sizeof(error_msg),
         "rmw_introspect: failed to create publisher via %s: %s",
         g_real_rmw->implementation_name.c_str(),
         rmw_get_error_string().str);
RMW_SET_ERROR_MSG(error_msg);
return ret;
#+END_SRC

* Global State Management

** Global Variables

#+BEGIN_SRC cpp
namespace rmw_introspect {
namespace internal {

// Global pointer to real RMW functions (initialized in rmw_init)
extern RealRMW* g_real_rmw;

// Mutex for initialization
extern std::mutex g_init_mutex;

// Initialization counter (for multiple contexts)
extern std::atomic<size_t> g_context_count;

}  // namespace internal
}  // namespace rmw_introspect
#+END_SRC

** Initialization Guard

#+BEGIN_SRC cpp
rmw_ret_t rmw_init(
  const rmw_init_options_t* options,
  rmw_context_t* context)
{
  std::lock_guard<std::mutex> lock(g_init_mutex);

  // First initialization?
  if (g_context_count == 0) {
    const char* delegate_to = std::getenv("RMW_INTROSPECT_DELEGATE_TO");
    if (delegate_to && *delegate_to) {
      // Load real RMW
      g_real_rmw = new RealRMW;
      if (!g_real_rmw->load(delegate_to)) {
        delete g_real_rmw;
        g_real_rmw = nullptr;
        RMW_SET_ERROR_MSG("failed to load real RMW implementation");
        return RMW_RET_ERROR;
      }
    }
    // Otherwise stay in recording-only mode (g_real_rmw = nullptr)
  }

  ++g_context_count;

  // ... rest of initialization
}
#+END_SRC

** Cleanup Guard

#+BEGIN_SRC cpp
rmw_ret_t rmw_context_fini(rmw_context_t* context)
{
  std::lock_guard<std::mutex> lock(g_init_mutex);

  --g_context_count;

  // Last context being finalized?
  if (g_context_count == 0 && g_real_rmw) {
    g_real_rmw->unload();
    delete g_real_rmw;
    g_real_rmw = nullptr;
  }

  // ... rest of cleanup
}
#+END_SRC

* Type Support Forwarding

** Key Principle

Type support structures (~rosidl_message_type_support_t~, etc.) are passed
through *unchanged* to the real RMW. We only extract type names for
introspection; we never modify or wrap type support.

#+BEGIN_SRC cpp
rmw_publisher_t* rmw_create_publisher(
  const rmw_node_t* node,
  const rosidl_message_type_support_t* type_support,  // <-- pass through
  const char* topic_name,
  const rmw_qos_profile_t* qos_profile,
  const rmw_publisher_options_t* publisher_options)
{
  // Extract type name for introspection
  std::string message_type = extract_message_type(type_support);

  // Forward type_support AS-IS to real RMW
  rmw_publisher_t* real_pub = g_real_rmw->create_publisher(
    real_node,
    type_support,  // <-- unchanged
    topic_name,
    qos_profile,
    publisher_options);

  // ...
}
#+END_SRC

* References

- [[file:architecture.org][Architecture Design Document]]
- [[file:implementation-guide.org][Implementation Guide]]
- [[file:roadmap.org][Development Roadmap]]
